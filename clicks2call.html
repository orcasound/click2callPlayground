<!DOCTYPE html>
<html>
<head>
    <title>Looking and Listening to Clicks</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavefile"></script>
    <script src="https://cdn.jsdelivr.net/npm/wave-resampler"></script>
    <script src="FFT.js"></script>
            <!-- flex 1 and 4 below divide the width into 20% / 80%  -->
    <style>
        .psd_spec-container {
            display: flex;
        }
        #PSD_plot {
            flex: 1;
            height: 700px;
        }
        #spectrogram_plot {
            flex: 4;
            height: 700px;
        }
    </style>
</head>
<body>
    <label for="amplitude">Amplitude:</label>
    <input type="number" id="amplitude" value="1"/>
    <div id="center" style="background-color: #ffffff; width:100%;">
        <label>Click period, T (microSec): </label>
        <input id="T_click" style="width:5%;" value="30" type="text" onChange="replotClickFunction()"/>
    </div>
    <div id="center" style="background-color: #ffffff; width:100%;">
        <label>Damping time constant, tau (microSec): </label>
        <input id="tau" style="width:5%;" value="80" type="text" onChange="replotClickFunction()"/>
    </div>
    <div id="center" style="background-color: #ffffff; width:100%;">
        <label>Time (microSec): </label>
        <input id="T_window" style="width:20%;" value="300" type="text" onChange="replotClickFunction()"/>
    </div>
    <div id="center" style="background-color: #ffffff; ">
        <label>Function x(t): </label>
        <input id="Click_func" style="width:60%;" value="(exp(-t/tau)**2)*cos(2*PI*t/T)*sin(2*PI*t/T)" type="text"
               onChange="replotClickFunction()"/>
    </div>
    <div id="center" style="background-color: #ffffff; ">
        <label>Click separation (microSec): </label>
        <input id="click_sep" style="width:5%;" value="1000" type="text" onChange="replotClickFunction()"/>
    </div>
    <div id="center" style="background-color: #ffffff; width:100%;">
        <select id="modulation" onchange="Plot_Spectogram()">
                <option value="Nomod">No Call Modulation</option>
                <option value="Upsweep">Call: upsweep</option>
                <option value="Downsweep">Call: downsweep</option>
                <option value="Excitement">Call: Excitement</option>
        </select>
        <label> Mod Start (Sec): </label>
        <input id="modStart" style="width:2%;" value="0.5" type="text" onChange="replotClickFunction()"/>
        <label> Mod Parameter: </label>
        <input id="modParm" style="width:2%;" value="1.5" type="text" onChange="replotClickFunction()"/>
    </div>

    <div id="clickPlot"></div>
    <label id="label1"> Desired audio samplerate: </label>
    <input id="Audio samplerate" style="width:3%;" value="48000" type="text" onchange="resampleFunction()">
    <button id="replot click">Replot</button>

    <input id="low_pass" type="checkbox" onchange="resampleFunction()">
    <label>Low Pass Filter</label>
    <input id="cutoff" style="width:3%;" value="24000" type="text" onchange="resampleFunction()">
    <label>Plot t1 (microsec)</label>
    <input id="t1" style="width:3%;" value="00" type="text" onchange="resampleFunction()">
     <label>Plot t2 (microsec)</label>
    <input id="t2" style="width:3%;" value="2000" type="text" onchange="resampleFunction()">

    <button id="resample">Resample</button>
<!--    <button id="plotResample">Plot Resampled Clicks</button>-->
    <button id="playResample">Play 2 sec of Resampled Clicks</button>

    <div id="center" style="background-color: #ffffff; width:100%;">
    <label id="label2">DEBUG</label>
    <select id="DEBUG" onchange="runDEBUG()">
            <option value="none">None</option>
            <option value="squareWav">Sawtooth Wave</option>
            <option value="orcaCall">Orca Call</option>
    </select>

    <p id="msg"></p>
    <div id="resampledClicksPlot"></div>
    <label id="label2"> Number of ms per PSD slice </label>
    <input id="dt" style="width:5%;" value="50" type="text" onchange="Plot_Spectogram()">
    <label id="label3"> Time (s) for PSD plot  </label>
    <input id="t_PSD" style="width:5%;" value="0.5" type="text" onchange="Plot_Spectogram()">
    <div id="center" style="background-color: #00b5e2; width:100%;">
    <select id="FFTwindow" onchange="Plot_Spectogram()">
            <option value="None">FFT Window: None</option>
            <option value="Cosine">FFT Window: Cosine</option>
            <option value="Hanning">FFT Window: Hanning</option>
            <option value="Hamming">FFT Window: Hamming</option>
            <option value="Blackman">FFT Window: Blackman</option>
            </select>
    </div>
    <input id="db_psd" type="checkbox" onchange="Plot_Spectogram()">
    <label>dB PSD   </label>

    <input id="log_freq" type="checkbox" onchange="Plot_Spectogram()">
    <label>log Frequency</label>

    <div class="psd_spec-container">
        <div id="PSD_plot"></div>
        <div id="spectrogram_plot"></div>
    </div>
<!--    <script src="script_0.js"></script>-->
    <script>
        ///////////   GLOBAL PARAMETER(s)
        // length of audio sample is 2 seconds
        window.global_taudio = 2
        window.global_resampled = false //document.getElementById("low_pass").checked
        document.getElementById("DEBUG").value = 'none';
        // Function to replot the function with a new amplitude
        function replotClickFunction() {
            var amplitude = parseFloat(document.getElementById('amplitude').value);
            const funcString = document.getElementById('Click_func').value;
            var T = parseFloat(document.getElementById('T_click').value);
            var tau = parseFloat(document.getElementById('tau').value);
            var T_window = parseFloat(document.getElementById('T_window').value);
            var click_sep = parseFloat(document.getElementById('click_sep').value);
            var customFunction = new Function('T', 'tau', 'exp', 'cos', 'sin', 'PI', 't', `return ${funcString}`);
            var tmus = new Array(T).fill(0);
            var yAmp = new Array(T).fill(0);
            with (Math) {
                for (var n = 0; n < T_window; n += 1) {
                    tmus[n] = n
                    yAmp[n] = amplitude * customFunction(T, tau, exp, cos, sin, PI, n);
                }
//                console.log(yAmp)
            }
            var tmus2 = new Array(2 * click_sep).fill(0);
            var yAmp2 = new Array(2 * click_sep).fill(0);
            window.global_tmus2 = tmus2
            window.global_yAmp2 = yAmp2  // make this global so can play as a sound
            with (Math) {
                for (var n = 0; n < 2 * click_sep; n += 1) {
                    tmus2[n] = n;
                    yAmp2[n] = amplitude * customFunction(T, tau, exp, cos, sin, PI, n)
                    if (n > click_sep) {
                        yAmp2[n] = yAmp2[n] + amplitude * customFunction(T, tau, exp, cos, sin, PI, n - click_sep);
                    }
                }
            }

            // Create a trace for the click function
            var trace1 = {
                x: tmus,
                y: yAmp,
                type: 'scatter'
            };
            var trace2 = {
                x: tmus2,
                y: yAmp2,
                xaxis: 'x2',
                yaxis: 'y2',
                type: 'scatter'
            };
            // Define the layout of the plot
            var layout = {
                title: 'One Click (left) and Two successive Clicks (right)',
                yaxis: {
                    title: 'Amplitude'
                },
                height: 300,
                xaxis: {domain: [0, 0.3], title: "Time (microsec)"},
                yaxis2: {anchor: 'x2'},
                xaxis2: {domain: [0.33, 1], title: "Time (microsec)"}

            };
            data = [trace1, trace2];
            // Plot the click function using Plotly
            Plotly.newPlot('clickPlot', data, layout);

            ////// Construct the full (maybe modulated) call time series at the high sample rate (1e6)  length = global_taudio
            window.global_tCall = new Array(global_taudio * 1e6).fill(0);
            window.global_yAmpCall = new Array(global_taudio * 1e6).fill(0);
            var idx = 0;
            for (var n = 0; n < global_yAmpCall.length; n += 1) {
                global_tCall[n] = n / 1e6   // time axis in seconds for full call
                global_yAmpCall[n] = yAmp2[idx];
                idx += 1;
                if (idx == yAmp2.length) {
                    idx = 0;
                }
            }

            // resample the call
            resampleFunction();
        };

        // Event listener for the Replot button
        document.getElementById('replot click').addEventListener('click', replotClickFunction);
        replotClickFunction();

        var msg      = document.getElementById('msg');
        document.getElementById('resample').addEventListener('click', resampleFunction);

        // Event listener for the Play Resampled Clicks button
        document.getElementById('playResample').addEventListener('click', playResampledClicks);
/////////////////////////////////////////////////////////////////////////
        class SecondOrderLowPassFilter {
          constructor(sampleRate, cutoffFrequency, Q) {
            this.sampleRate = sampleRate;
            this.cutoffFrequency = cutoffFrequency;
            this.Q = Q;

            this.xn1 = 0; // x[n-1]
            this.xn2 = 0; // x[n-2]
            this.yn1 = 0; // y[n-1]
            this.yn2 = 0; // y[n-2]

            // Calculate filter coefficients
            let omega = 2 * Math.PI * this.cutoffFrequency / this.sampleRate;
            let alpha = Math.sin(omega) / (2 * this.Q);
            let cosOmega = Math.cos(omega);

            this.b0 = (1 - cosOmega) / 2;
            this.b1 = 1 - cosOmega;
            this.b2 = (1 - cosOmega) / 2;
            this.a0 = 1 + alpha;
            this.a1 = -2 * cosOmega;
            this.a2 = 1 - alpha;
          }

          filter(input) {
            // Direct Form 1 implementation
            let output = (this.b0 / this.a0) * input +
                         (this.b1 / this.a0) * this.xn1 +
                         (this.b2 / this.a0) * this.xn2 -
                         (this.a1 / this.a0) * this.yn1 -
                         (this.a2 / this.a0) * this.yn2;

            // Update state variables
            this.xn2 = this.xn1;
            this.xn1 = input;
            this.yn2 = this.yn1;
            this.yn1 = output;

            return output;
          }
        }
        class ThirdOrderLowPassFilter {
            constructor(sampleRate, cutoffFrequency, Q) {
                this.sampleRate = sampleRate;
                this.cutoffFrequency = cutoffFrequency;
                this.Q = Q;

                this.xn1 = 0; // x[n-1]
                this.xn2 = 0; // x[n-2]
                this.xn3 = 0; // x[n-3]
                this.yn1 = 0; // y[n-1]
                this.yn2 = 0; // y[n-2]
                this.yn3 = 0; // y[n-3]

                // Calculate filter coefficients
                let omega = 2 * Math.PI * this.cutoffFrequency / this.sampleRate;
                let alpha = Math.sin(omega) / (2 * this.Q);
                let cosOmega = Math.cos(omega);

                this.b0 = (1 - cosOmega) / 2;
                this.b1 = 1 - cosOmega;
                this.b2 = (1 - cosOmega) / 2;
                this.b3 = 0;
                this.a0 = 1 + alpha;
                this.a1 = -2 * cosOmega;
                this.a2 = 1 - alpha;
                this.a3 = 0;
            }

            filter(input) {
                // Direct Form 1 implementation
                let output = (this.b0 / this.a0) * input +
                             (this.b1 / this.a0) * this.xn1 +
                             (this.b2 / this.a0) * this.xn2 +
                             (this.b3 / this.a0) * this.xn3 -
                             (this.a1 / this.a0) * this.yn1 -
                             (this.a2 / this.a0) * this.yn2 -
                             (this.a3 / this.a0) * this.yn3;

                // Update state variables
                this.xn3 = this.xn2;
                this.xn2 = this.xn1;
                this.xn1 = input;
                this.yn3 = this.yn2;
                this.yn2 = this.yn1;
                this.yn1 = output;

                return output;
            }
        }

        //////////////////////////////////////////////////////////////
        function lowpassFunction(yampdata){  // low pass the full call data series
            const cutoffFrequency = parseInt(document.getElementById('cutoff').value)
            const sampleRate = 1e6
            const Q = 0.707; // Quality factor (Butterworth)
            const filter = new ThirdOrderLowPassFilter(sampleRate, cutoffFrequency, Q);

            // Filter input signal
            const inputSignal = yampdata;
      //      const inputSignal = Array.from({length: 2000}, () => Math.random() * 10);
            const outputSignal = [];
            for (let i = 0; i < inputSignal.length; i++) {
              outputSignal.push(filter.filter(inputSignal[i]));

            }
            for (let i = 0; i < 2000; i+=10) {
                console.log(i, inputSignal[i], outputSignal[i]);
            }
            return outputSignal;
        }
        function resampleFunction(){
            const samplerate = parseInt(document.getElementById('Audio samplerate').value);
            window.global_audioSamplerate = samplerate
            if (global_resampled & document.getElementById("low_pass").checked) {
                var newSamples = waveResampler.resample(lowpassFunction(global_yAmpCall), 1e6, samplerate);
            } else {
                var newSamples = waveResampler.resample(global_yAmpCall, 1e6, samplerate);
            }
            global_resampled = true
            window.global_callResampled = newSamples;

            plotResampledClicks();
        }

         // Event listener for the Plot Resampled Clicks button
        // document.getElementById('plotResample').addEventListener('click', resampledClicksPlot);
        // resampledClicksPlot();

        function plotResampledClicks(){
  //          msg.innerHTML = "ready to plot resampled clicks " + global_callResampled.length +"  " + global_audioSamplerate

            const t1 = parseInt(document.getElementById('t1').value)
            const t2 = parseInt(document.getElementById('t2').value)
            var tAxis = global_tCall.slice(t1, t2);
            var yCall = global_callResampled.slice(t1, t2);

            var trace = {
                x: tAxis,
                y: yCall,
                type: 'scatter'
            };
            var layout = {
                title: "Resampled Time Series",
                height: 300,
                yaxis: {
                    title: 'Amplitude'
                }
            };
            data = [trace]
            // Plot the resampled clicks using Plotly
            Plotly.newPlot('resampledClicksPlot', data, layout);

             Plot_Spectogram()
        };

        function playResampledClicks(){ // Function to play audio from the array
            msg.innerHTML = "Play resampled click train"

            var audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Create an empty AudioBuffer with 1 channel and desired length
            var audioBuffer = audioContext.createBuffer(1, global_callResampled.length, global_audioSamplerate);

            // Fill the AudioBuffer with data from ydata
            var channelData = audioBuffer.getChannelData(0);
            for (var i = 0; i < global_callResampled.length; i++) {
                channelData[i] = global_callResampled[i];
            }

            // Create an AudioBufferSourceNode
            var source = audioContext.createBufferSource();
            source.buffer = audioBuffer;

            // Connect the source to the destination (speakers)
            source.connect(audioContext.destination);

            // Start playing the audio
            source.start();
        };

        function getMax(a){
            return Math.max(...a.map(e => Array.isArray(e) ? getMax(e) : e));
}

        /////////////////////////////////////////////////////// Spectrogram code
        function Plot_Spectogram() {
  //            console.log("new call to Plot_Spectogram");

              var full_x = new Array(global_resampled.length);
              full_x = [...global_callResampled];  // this is a clone using "spread syntax"


              N_perSlice = Math.floor(document.getElementById("dt").value * global_audioSamplerate / 1000);
              //// time for PSD plot
              t_PSD = document.getElementById("t_PSD").value;
              var hop = Math.floor(N_perSlice/2)  // advance psd's by hop for each successive psd

              Nfft = 2048

              X_abs_bin = new Array(Nfft).fill(0);
              n_bins = Math.floor(global_callResampled.length/hop)

              bin_PSD = Math.floor((t_PSD/global_taudio)*n_bins)

              var imageSpectrogram = new Array(n_bins).fill(0);
              var FFTwindow = document.getElementById("FFTwindow").value;
              var max_x_abs = 0
              for (var bin = 0; bin < n_bins; bin += 1) {
                  var x_bin = new Array(Nfft).fill(0);
                  for (var i = 0; i < Nfft; i += 1) {
                      if (FFTwindow == "Cosine") {
                          x_bin[i] = full_x[bin * hop + i] * Math.sin(Math.PI * i / Nfft);
                      } else if (FFTwindow == "Hanning") {
                          x_bin[i] = full_x[bin * hop + i] * 0.5 * (1 - Math.cos(2 * Math.PI * i / (Nfft - 1)));
                      } else if (FFTwindow == "Hamming") {
                          x_bin[i] = full_x[bin * hop + i] * (0.53836 - .46164 * Math.cos(2 * Math.PI * i / (Nfft - 1)));
                      } else if (FFTwindow == "Blackman") {
                          x_bin[i] = full_x[bin * hop + i] * (0.42 - .5 * Math.cos(2 * Math.PI * i / (Nfft - 1)) + .08 * Math.cos(4 * Math.PI * i / (Nfft - 1)));
                      } else if (FFTwindow == "None") {
                          x_bin[i] = full_x[bin * hop + i];
                      }
                  }

                  fft = FFT(x_bin);
                  frec = new Array(Nfft / 2).fill(0);
                  var timeaxis = new Array(n_bins).fill(0);
                  my_X_abs = new Array(x_bin.length / 2).fill(0);
                  for (var i = 0; i < Nfft / 2; i += 1) {
                      if (document.getElementById("db_psd").checked) {
                          my_X_abs[i] = Math.log10(Math.sqrt(fft[i].re * fft[i].re + fft[i].im * fft[i].im));
                      } else {
                          my_X_abs[i] = Math.sqrt(fft[i].re * fft[i].re + fft[i].im * fft[i].im);
                      }
                      if (Math.abs(my_X_abs[i]) > max_x_abs){
                          max_x_abs = Math.abs(my_X_abs[i]);
                      }
                      frec[i] = i * global_audioSamplerate / Nfft;
                      // if (bin == 0) {
                      //     console.log(i, frec[i], my_X_abs[i]);
                      // }

                  }
                  imageSpectrogram[bin] = my_X_abs ;

                  if (bin === bin_PSD){
                      var plot_PSD = my_X_abs

                  }


              }
              //console.log("in Spectrogram, maxes ", getMax(imageSpectrogram), max_x_abs)
              // for (var bin = 0; bin < imageSpectrogram.length; bin += 1) {
              //     for (var i = 0; i < imageSpectrogram[bin].length; i += 1) {
              //         imageSpectrogram[bin][i] /= max_x_abs;
              //     }
              // }
              // for (var i = 0; i < imageSpectrogram[0].length; i += 1) {
              //     console.log(i, frec[i], imageSpectrogram[0][i])
              // }
              // console.log(getMax(imageSpectrogram))

              var timeaxis = new Array(n_bins).fill(0);
              for (var n = 0; n < n_bins; n += 1) {
                  timeaxis[n] = (n / n_bins) * global_taudio;
              }
                     // Sample data for graph 1
            var data1 = [{
                x: frec,
                y: plot_PSD,
                type: 'scatter',
                name: 'PSD'
            }];


            // Sample data for graph 2
            var data2 = [{
                x: timeaxis,
                y: frec,
                z: imageSpectrogram,
                type: 'heatmap',
                xtype: "array",
                name: 'Spectrogram',
                yaxis: 'y2'
            }];
            if (document.getElementById("log_freq").checked) {
                // Layout for graph 1
                var layout1 = {
                    title: 'PSD',
                    xaxis: {
                        title: 'Log Frequency',
                        type: 'log'
                    },
                    yaxis: {
                        title: 'PSD'
                    }
                };
                // Layout for graph 2
                var layout2 = {
                    title: 'Spectrogram',
                    xaxis: {
                        title: 'Time (sed)'
                    },
                    yaxis2: {
                        title: 'Log Frequency (hz)',
                        //              range: [100, 20000],
                        type: 'log',
                        overlaying: 'y',
                        side: 'left'
                    }
                };
            } else {
                                // Layout for graph 1
                var layout1 = {
                    title: 'PSD',
                    xaxis: {
                        title: 'Frequency'
                    },
                    yaxis: {
                        title: 'PSD'
                    }
                };
                // Layout for graph 2
                var layout2 = {
                    title: 'Spectrogram',
                    xaxis: {
                        title: 'Time (sec)'
                    },
                    yaxis2: {
                        title: 'Frequency (hz)',
                        //              range: [100, 20000],
                        overlaying: 'y',
                        side: 'left'
                    }
                };
            }
            // Plot graph 1
            Plotly.newPlot('PSD_plot', data1, layout1);

            // Plot graph 2
            Plotly.newPlot('spectrogram_plot', data2, layout2);
            var update = {
                  "transpose": true
            };
            Plotly.restyle('spectrogram_plot', update, 0);
          }
        function runDEBUG(){
            dbg = document.getElementById('DEBUG').value;
            if (dbg = "squareWav"){
                // setup a 1 Mhz square wave and run through low pass and resample etc.
                period = 1000;  // microseconds
                amp = parseFloat(document.getElementById('amplitude').value);
                cnt = 0;
                theAmp = amp;
                for (i=0; i<global_yAmpCall.length; i++){
                    global_yAmpCall[i] = theAmp * (cnt +1)/period;
                    cnt += 1;
                    if (cnt === period){
                        theAmp = -theAmp;
                        cnt = 0;
                    }
                }
                 // resample the call
                resampleFunction();

            }
        }
    </script>
</body>
</html>